# 1. **Что происходит, когда я вбиваю в адресную строку моего браузера [google.com](https://www.google.com/)? Как запрос доходит до сервера, и как идет обратно? Гранулярность — настолько маленькая, насколько возможно.**
### 1. Пользователь вводит в браузере адрес сайта  
### 2. Браузер начинает искать сервер  
   За работу любого сайта обычно отвечает один из миллионов серверов, подключенных к интернету. Адрес сервера — это  уникальный набор цифр, который называется IP-адресом. Например, для vc.ru— это сервер 85.119.149.83  

   **Поэтому первым делом браузеру нужно понять, какой IP-адрес у сервера, на котором находится сайт.**  
   Такая информация хранится в распределенной системе серверов — DNS (Domain Name System). Система работает как общая «контактная книга», хранящаяся на распределенных серверах и устройствах в интернете. 

   Однако перед тем, как обращаться к DNS, браузер пытается найти запись об IP-адресе сайта в ближайших местах, чтобы сэкономить время:  

   - Сначала в своей **истории подключений**. Если пользователь уже посещал сайт, то в браузере могла сохраниться информация c IP-адресом сервера.  
   - В **операционной системе**. Не обнаружив информации у себя, браузер обращается к операционной системе, которая также могла сохранить у себя DNS-запись. Например, если подключение с сайтом устанавливалось через одно из установленных на компьютере приложений.  
   - В **кэше роутера**, который сохраняет информацию о последних соединениях, совершенных из локальной сети.
### 3. Браузер отправляет запрос к DNS-серверам
   Не обнаружив подходящих записей в кэше, браузер формирует запрос к DNS-серверам, расположенным в интернете.  
   Например, если нужно найти IP-адрес сайта mail.vc.ru, браузер спрашивает у ближайшего DNS-сервера «Какой IP-адрес у сайта mail.vc.ru?».  

   Сервер может ответить: «Я не знаю про mail.vc.ru, но знаю сервер, который отвечает за vc.ru». Запрос переадресовывается дальше, на сервер «выше», пока в итоге один из серверов не найдет ответ об IP-адресе для сайта.  

   ![dns](dns.png "how dns works")
### [Крутой видосик о том как работает DNS](https://www.youtube.com/watch?v=t2NMbSarXC4)
### [DNS в комиксах](https://www.verisign.com/en_US/website-presence/online/how-dns-works/index.xhtml)
   
### 4. Браузер устанавливает соединение с сервером
   Как только браузер узнал IP-адрес нужного сервера, он пытается установить с ним соединение. В большинстве случаев для этого используется специальный протокол — TCP.

   TCP — это набор правил, который описывает способы соединения между устройствами, форматы отправки запросов, действия в случае потери данных и так далее.

   Например, для установки соединения между браузером и сервером в стандарте TCP используется система «трёх рукопожатий». Работает она так:  
   - Устройство пользователя отправляет специальный запрос на установку соединения с сервером — называется **SYN**-пакет.  
   - Сервер в ответ отправляет запрос с подтверждением получения SYN-пакета — называется **SYN/ACK**-пакет.  
   - В конце устройство пользователя при получении SYN/ACK-пакета отправляет пакет с подтверждением — **ACK**-пакет. В этот момент соединение считается установленным.
### 5. Браузер отправляет HTTP-запрос, чтобы получить контент сайта
   После установки соединения браузер отправляет специальный запрос, в котором просит сервер отправить данные для отображения страницы. В этом запросе содержится информация о самом браузере, временные файлы, требования к соединению и так далее.

   **Задача браузера — как можно подробнее объяснить серверу, какая именно информация ему нужна.**

   В общении браузера и сервера выделяют два типа запросов. GET-запрос используется для получения данных с сервера — например, отобразить картинку, текст или видео. POST-запрос — используется для отправки данных из браузера на сервер, например, когда пользователь отправляет сообщение, картинку или загружает файл.

    Почти все сайты обмениваются информацией с сервером в зашифрованном формате — с помощью HTTPS-протокола. В отличие от HTTP-протокола, в HTTPS используется шифрование, а безопасность подключения подтверждается специальным сертификатом.
### 6. Сервер обрабатывает запрос
   Сервер получил запрос от браузера с подробным описанием того, что ему требуется. Теперь ему нужно обработать этот запрос. Этой задачей занимается специальное серверное программное обеспечение — например, nginx или Apache. Чаще всего такие программы принято называть веб-серверами.

   Веб-сервер в свою очередь перенаправляет запрос на дальнейшую обработку к программе-обработчику — например: GO, PHP, Ruby или Python. Программа внимательно изучает содержимое запроса — например, понимает, в каком формате нужно отправить ответ и какие именно файлы нужны. И собирает ответ.
### 7. Сервер отправляет ответ браузеру
   Когда ответ сформирован, он отправляется веб-сервером обратно браузеру. В ответе как правило содержится контент для отображения веб-страницы, информация о типе сжатия данных, способах кэширования, файлы cookie, которые нужно записать и так далее.

    Чтобы обмен данными был быстрым, браузер и сервер обмениваются сразу множеством небольших пакетов данных — как правило, в пределах 8 КБ. Все пакеты имеют специальные номера, которые помогают отслеживать последовательность отправки и получения данных.
### 8. Браузер обрабатывает полученный ответ и «рисует» веб-страницу
   Браузер распаковывает полученный ответ и постепенно начинает отображать полученный контент на экране пользователя — этот процесс называется **рендерингом**.

   Сначала браузер загружает только основную структуру HTML-страницы. Затем последовательно проверяет все теги и отправляет дополнительные GET-запросы для получения с сервера различных элементов — картинки, файлы, скрипты, таблицы стилей и так далее. Поэтому по мере загрузки страницы браузер и сервер продолжают обмениваться между собой информацией.

   Параллельно с этим на компьютер как правило сохраняются статичные файлы пользователя — чтобы при следующем посещении не загружать их заново и быстрее отобразить пользователю содержимое страницы.

   Как только рендеринг завершен — пользователю отобразится полностью загруженная страница сайта.


# 2.  **В чем отличие протоколов TCP и UDP? В каком случае UDP предпочтительнее?**
### [Крутой видосик о TCP и UDP](https://www.youtube.com/watch?v=yMSJKBQINAc&t=3s)

# 3.  **Модель OSI?**
### [Крутой видосик про OSI](https://www.youtube.com/watch?v=je0QFU7p5Oo)

# 3.  **Что такое DHCP?**
### [Крутой видосик про DHCP](https://www.youtube.com/watch?v=XPRYaGCkXJ8)

# 4.  **HTTP и HTTPS**
HTTP (HyperText Transfer Protocol) - общепринятый протокол передачи данных и является
основным протоколом для коммуникации веб-приложений.
Изначально протокол был спроектирован для передачи гипертекстовых документов, что
можно заметить по словосочетанию HyperText из аббревиатуры. Однако сейчас он
используется для передачи данных разных форматов и не ограничивается одним лишь
гипертекстом.
HTTP работает поверх протокола TCP - одного из основных протоколов передачи данных
по сети.

Сегодня большинство сайтов работают по расширенному HTTP протоколу - HTTPS.
Приставка S в конце означает Secure(т.е. безопасный). Данный протокол по умолчанию
использует 443-ий TCP-порт.
HTTPS работает через шифрованный транспортный механизм TLS (а до этого SSL). TLS
это криптографический протокол, который обеспечивает защищенную передачу данных
по сети.
Протокол позволяет безопасно передавать конфиденциальные данные пользователей,
например пароли, номера кредиток, документы и тд.


# 5.  **Анатомия HTTP сообщений**
Сообщение состоит из 3х частей, которые передаются в указанном порядке:
1. Стартовая строка (Starting line)
2. Заголовки (Headers)
3. Тело сообщения (Message Body)
Первые две части обязательны, в то время как тело сообщения может быть пустым.
Стартовая строка различается для запросов и ответов. При запросе указывается метод,
URI запроса и версия протокола. При ответе же отправляется версия протокола, статус
код и его текстовое пояснение.

**Пример.**  
Допустим, вы пишите в адресной строке браузера
youtube.com. Браузер формирует HTTP-запрос, в котором стартовая строка имеет
следующий вид:  

**GET / HTTP/1.1**

Где:  
GET - метод HTTP запроса  
/ - URI запроса  
HTTP/1.1 - версия протокола  

Далее на следующей строке указываются так называемые хедеры (заголовки).

**GET / HTTP/1.1**  
**Host: youtube.com**  

Обработав запрос, сервер присылает ответ, стартовая строка которого имеет следующий
вид:

**HTTP/1.1 200 OK**

Где:  
HTTP/1.1 - версия протокола  
200 - Статус код  
OK - краткое текстовое объяснение кода ответа  
# 5.  **HTTP Методы**
Методы определяют запрашиваемое действие. Протокол не ограничивает значение для
методов, однако для стандартизации используется общепринятый набор глаголов:
- GET - получение ресурса
- POST - создание ресурса
- PUT - обновление ресурса
- DELETE - удаление ресурса
- TRACE, OPTIONS, CONNECT, PATCH, HEAD - менее популярные методы, которые
используются достаточно редко.

# 5.  **HTTP Заголовки**
keep alive  
Используются для передачи дополнительной информации между сервером и клиентом.
Заголовки указываются в формате *<имя>: <значение>* и их может быть сколько угодно.
Каждый заголовок определяется с новой строки.
Заголовки могут иметь какие-угодно имена и значения, но по аналогии с методами,
существует определенный набор общепринятых стандартов.

# 5.  **HTTP статус коды**
Код указывает на статус обработки запроса сервером. Значение статус кодов не
ограничено протоколом, однако они также имеют общепринятую классификацию.
1. Информационные (100 - 199)
2. Успешные (200 - 299)
3. Перенаправления (300 - 399)
4. Клиентские ошибки (400 - 499)
5. Серверные ошибки (500 - 599)

# 5.  **URI и URL**
# 5.  **URL Query (Query string)**
В URL можно передавать набор параметров, это называется URL Query(или Query string).
После самого адреса указывается знак вопроса ?, который объявляет начало строки с
параметрами, далее параметры передаются в формате:
*имя_переменной1=значение1&имя_переменной2=значение2*, разделяя значения с помощью символа &.  
**Пример.**  
https://example.com/search?a=1&sort=desc


# 6.  **Различия HTTP/1.1 И HTTP/2?**
https://www.8host.com/blog/v-chem-raznica-mezhdu-http1-1-i-http2/
# 7.  **CORS**
   **Cross-origin resource sharing(CORS)** — технология современных браузеров, которая позволяет предоставить веб-страницам доступ к ресурсам из другого источника.
   Запросы на другой источник(cross-origin запросы) – отправленные на другой домен (или даже поддомен), или протокол, или порт – требуют специальных заголовков от удалённой стороны.
   CORS существует для защиты интернета от злых хакеров.
   
   Есть два вида запросов на другой источник:
   1. Простые.
   2. Все остальные.

   **Простой запрос** – это запрос, удовлетворяющий следующим условиям:
   1. Простой метод: GET, POST или HEAD
   2. Простые заголовки – разрешены только:
      * Accept
      * Accept-Language
      * Content-Language
      * Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или text/plain

   **Любой другой запрос считается «непростым»**. Например, запрос с методом PUT или с HTTP-заголовком API-Key не соответствует условиям.

    Основное их отличие заключается в том, что простые запросы с давних времён выполнялись с использованием тегов <form> или <script>, в то время как непростые долгое время были невозможны для браузеров.
    Практическая разница состоит в том, что простые запросы отправляются сразу с заголовком Origin, а для других браузер делает предварительный запрос, спрашивая разрешения.
   
   Когда мы пытаемся сделать непростой запрос, браузер посылает специальный предварительный запрос с методом OPTIONS(«предзапрос», по англ. «preflight»), который спрашивает у сервера – согласен ли он принять такой непростой запрос или нет? И, если сервер явно не даёт согласие в заголовках, непростой запрос не посылается.

   **Для простых запросов:**  
   - в запросе: браузер посылает заголовок Origin с источником.
   - в ответе: для запросов без авторизационных данных (не отправляются умолчанию) сервер должен установить:
        * Access-Control-Allow-Origin в * или то же значение, что и Origin
   - в ответе: для запросов с авторизационными данными сервер должен установить:
        * Access-Control-Allow-Origin в то же значение, что и Origin
        * Access-Control-Allow-Credentials в true

    Дополнительно, чтобы разрешить JavaScript доступ к любым заголовкам ответа, кроме Cache-Control, Content-Language, Content-Type, Expires, Last-Modified или Pragma, сервер должен перечислить разрешённые в заголовке Access-Control-Expose-Headers
   
   **Для непростых запросов перед основным запросом отправляется предзапрос:**
   - в запросе: браузер посылает запрос OPTIONS на тот же адрес с заголовками:
        * Access-Control-Request-Method – содержит запрашиваемый метод
        * Access-Control-Request-Headers – перечисляет непростые запрашиваемые заголовки
   - в ответе: сервер должен ответить со статусом 200 и заголовками:
        * Access-Control-Allow-Methods со списком разрешённых методов
        * Access-Control-Allow-Headers со списком разрешённых заголовков
        * Access-Control-Max-Age с количеством секунд для кеширования разрешений
   - затем отправляется основной запрос, применяется предыдущая «простая» схема
  
   ### [простое описание CORS](https://learn.javascript.ru/fetch-crossorigin)
   ### [подробное описание CORS](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS)
   ### [видео гайд по CORS](https://www.youtube.com/watch?v=Rx-G3uB__zI)

# 8.  **REST SOAP**
# 9.  **HTTP Cookie**
HTTP cookie (куки) - это небольшой набор данных, которые сервер присылает
веб-браузеру в специальном заголовке при ответе. Браузер сохраняет их у себя в памяти
и может использовать при дальнейших запросах на этот сервер.

Например, куки используются для того, штобы пользователь оставался авторизованным в
системе при каждом новом запросе. Они позволяют хранить информацию о состоянии
приложения
В основном, куки используются для:
- Управление сессиями (авторизация пользователя, состояние корзины в онлайн магазине)
- Персонализация (сохранение данных о пользовательских настройках, темах и тд.)
- Мониторинг (отслеживание действий пользователя)

Для создания куки, сервер посылает заголовок Set-Cookie в следующем формате:  
Set-Cookie: <cookie_name>=<cookie_value>

Когда браузер видит этот заголовок в ответе, он сохраняет значения в свое хранилище.
При последующих запросах на сервер, браузер будет добавлять к запросу заголовок:  
Cookie: <cookie_name>=<cookie_value>



# 9.  **Сессии и JWT токены. Statefull и Stateless**
# 10.  **Методы защиты от CSRF-атаки**
# 11.  **XSS**
# 12.  **SPA приложения**

