# 1. **С какими проблемами в кешировании данных сталкивался?**
# 2. **Как бы ты решал проблему, когда одновременно много клиентов не получают данные из кеша, и все одновременно идут в источник мастер данных(например, в БД)?**
# 3. **Плюсы и минусы реляционных СУБД и NoSQL решений. В каком случае лучше выбрать NoSQL?**



# 4. **CAP теорема**
Теорема CAP (теорема Брюера) — утверждение о том, что в любой распределенной системе возможно обеспечить не более двух из трёх следующих свойств:

- **Cогласованность(consistency)** — во всех вычислительных узлах в один момент времени данные не противоречат друг другу
- **Доступность(availability)** — любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают
- **Устойчивость к разделению**(partition tolerance) — расщепление распределённой системы на несколько изолированных секций не приводит к некорректности отклика от каждой из секций

# 5. **ACID**
Это набор из четырех требований к транзакционной системе, обеспечивающих максимально надежную и предсказуемую работу. Не все базы данных полностью реализуют ACID.

- **Атомарность (atomicity)**  
Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.

- **Согласованность (consistency)**  
Согласованность — это требование, подразумевающее, что в результате работы транзакции данные будут допустимыми. Это вопрос не технологии, а бизнес-логики: например, если количество денег на счете не может быть отрицательным, логика транзакции должна проверять, не выйдет ли в результате отрицательных значений.

- **Изолированность (isolation)**  
Гарантия того, что параллельные транзакции не будут оказывать влияния на результат других транзакций. Мы разобрались с изоляцией выше.

- **Долговечность (durability)**  
Изменения, получившиеся в результате транзакции, должны оставаться сохраненными вне зависимости от каких-либо сбоев. Иначе говоря, если пользователь получил сигнал о завершении транзакции, он может быть уверен, что данные сохранены.
# 6. **Транзакции**
**Транзакция** — это набор действий с данными, объединенный в логическую единицу. Она либо выполняется целиком, либо нет. Классический пример с операцией перевода денег со счета на счет:

    Начать транзакцию

    прочесть баланс на счету номер 5

    уменьшить баланс на 10 денежных единиц

    сохранить новый баланс счёта номер 5

    прочесть баланс на счету номер 7

    увеличить баланс на 10 денежных единиц

    сохранить новый баланс счёта номер 7

    Окончить транзакцию

Если эти операции выполнять вне транзакции, то ошибка в любой из них оставит оба счета в несогласованном состоянии: например, выйдет так, что деньги снимутся с одного счета, а на другой не придут. С транзакцией таких проблем нет — при ошибке откатятся все операции и для пользователя ничего не изменится.

Все звучит просто, когда с базой данных работает один пользователь: он выполняет транзакции одна за другой и не имеет никаких проблем с тем, что одна транзакция помешает другой. Все меняется, когда пользователей становится много.

Вот что может случиться при параллельном выполнении неизолированных транзакций.  

**Потерянное обновление**  
Когда две транзакции записывают разные значения в одну и ту же ячейку, одно из изменений теряется.

**Грязное чтение**  
Когда читаются данные, которые в этот момент изменяются транзакцией, а потом транзакция откатывается и данные исчезают.

**Неповторяющееся чтение**  
Когда несколько раз читаются данные, которые в этот момент изменяются транзакцией — каждый раз данные могут отказаться другими.

**Фантомное чтение**  
Одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.

# 7. **Изоляция транзакций**
Чтобы параллельные транзакции могли выполняться, не мешая друг другу, придумали концепцию изоляции транзакций. Всего есть четыре уровня изоляции, но некоторые базы данных вводят свои уровни.

**Чтение неподтверждённых данных (read uncommitted)**  
Самый низкий уровень изоляции. Можно свободно читать незафиксированные изменения других транзакций, но запись идет строго последовательно. Таким образом, исключается только проблема потерянных обновлений: гарантируется, что в итоге в ячейку запишут нужное значение все транзакции по очереди.

Обычно для этого используют блокировку на запись ячеек, предназначенных для изменения в рамках текущей транзакции. На чтение блокировки не ставятся.

**Чтение подтверждённых данных (read committed)**  
Можно свободно читать все изменения своей транзакции и зафиксированные изменения чужих транзакций. Исключаются потерянные обновления и грязное чтение, остаются проблемы неповторяемых чтений и фантомов.

**Повторяемое чтение (repeatable read)**  
Можно читать все изменения только своей транзации. Данные, измененные другими транзакциями, недоступны. Остается только проблема фантомных чтений.

**Сериализуемый (serializable)**  
Транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует.


# 8. **Индексы**
Индекс — объект базы данных, создаваемый с целью повышения производительности поиска данных.  
Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени. 

Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. 

Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, сбалансированного дерева.

**Что дают индексы**  
- Быстрый поиск записей по условию WHERE.
- Объединение таблиц с посредством JOIN. Необходимо использовать одинаковые типы сравниваемых полей. Если для сравнения необходимо произвести преобразование типов, то индексы использоваться не будут.
- Выборка наименьшего количества записей из таблицы. Если есть множественный индекс, то использоваться будет тот индекс, который находит самое маленький число строк.
- Поиск MAX и MIN значений для ключевых полей.
- Сортировка и группировка таблиц (…ORDER BY и GROUP BY).
- Извлечения данных не из таблицы с данными, а из индексного файла. Это возможно только в некоторых случаях, например, когда все извлекаемые поля проиндексированы.

**Пример:**  
~~~~sql
    CREATE TABLE people (
	last_name TEXT NOT NULL,
	first_name TEXT NOT NULL,
	dob TIMESTAMP NOT NULL,
	gender INT NOT NULL
);
~~~~
Создадим btree индекс
~~~~sql
    CREATE INDEX idx_people_name
    ON people USING btree
    (last_name, first_name, dob);
);
~~~~
**Индексирование btree (особенности)**  
**Можно:**  
- Поиск по полному значению
- Поиск по самому левому префиксу
- Поиск по префиксу столбца
- Поиск по диапазону значений
- Поиск по полному совпадению одной части и диапазону в другой части
- Запросы только по индексу  
**Нельзя:**  
- Поиск без использования левой части ключа
- Нельзя пропускать столбцы
- Оптимизация после поиска в диапазоне

      Также существуют индексы: hash-индексы, GiST (R-Tree), GIN (инвертированный), битовый индекс.
      Но в 99% случаев хорошо подходят btree индексы.

**Селективность** колонки определяется количеством записей в таблице с одинаковыми значениями.
Когда записей с одинаковым значением мало — селективность высокая. Такие колонки необходимо использовать первыми в составных индексах.

**Индексирование. Расплата.**  
- Увеличение числа индексов замедляет операции добавления, обновления, удаления строк таблицы, поскольку при этом приходится обновлять сами индексы.
- Индексы занимают дополнительный объем памяти, поэтому перед созданием индекса следует убедиться, что планируемый выигрыш в производительности запросов превысит дополнительную затрату ресурсов компьютера на сопровождение индекса.

**Индексирование. Итог.**
- В большинстве случаев нужен btree-индекс
- Для специфических случаев нужны GIN и GiST-индексы
- Битовые и hash-индексы PostgreSQL активно используюет в процессе выполнения запросов
- Частичные индексы могут заметно сократить объем индексов
- В PostgreSQL нужно явно создавать индексы для FOREIGN KEY
- Можно получить очень большой выйгрыш при использовании покрывающих индексов
- Каждый индекс требует долнительных затрат на своё поддержание (I/O и память)
# 9. **Нормальные формы**
# 10. **Денормализация**
# 11. **Репликация**
# 12. **Шардирование**